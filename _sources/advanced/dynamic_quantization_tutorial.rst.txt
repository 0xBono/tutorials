.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_advanced_dynamic_quantization_tutorial.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_advanced_dynamic_quantization_tutorial.py:


(experimental) Dynamic Quantization on an LSTM Word Language Model
==================================================================

**Author**: `James Reed <https://github.com/jamesr66a>`_

**Edited by**: `Seth Weidman <https://github.com/SethHWeidman/>`_

Introduction
------------

Quantization involves converting the weights and activations of your model from float
to int, which can result in smaller model size and faster inference with only a small
hit to accuracy.

In this tutorial, we'll apply the easiest form of quantization - 
`dynamic quantization <https://pytorch.org/docs/stable/quantization.html#torch.quantization.quantize_dynamic>`_ -
to an LSTM-based next word-prediction model, closely following the
`word language model <https://github.com/pytorch/examples/tree/master/word_language_model>`_
from the PyTorch examples.


.. code-block:: default


    # imports
    import os
    from io import open
    import time

    import torch
    import torch.nn as nn
    import torch.nn.functional as F







1. Define the model
-------------------

Here we define the LSTM model architecture, following the
`model <https://github.com/pytorch/examples/blob/master/word_language_model/model.py>`_
from the word language model example.


.. code-block:: default


    class LSTMModel(nn.Module):
        """Container module with an encoder, a recurrent module, and a decoder."""

        def __init__(self, ntoken, ninp, nhid, nlayers, dropout=0.5):
            super(LSTMModel, self).__init__()
            self.drop = nn.Dropout(dropout)
            self.encoder = nn.Embedding(ntoken, ninp)
            self.rnn = nn.LSTM(ninp, nhid, nlayers, dropout=dropout)
            self.decoder = nn.Linear(nhid, ntoken)

            self.init_weights()

            self.nhid = nhid
            self.nlayers = nlayers

        def init_weights(self):
            initrange = 0.1
            self.encoder.weight.data.uniform_(-initrange, initrange)
            self.decoder.bias.data.zero_()
            self.decoder.weight.data.uniform_(-initrange, initrange)

        def forward(self, input, hidden):
            emb = self.drop(self.encoder(input))
            output, hidden = self.rnn(emb, hidden)
            output = self.drop(output)
            decoded = self.decoder(output)
            return decoded, hidden

        def init_hidden(self, bsz):
            weight = next(self.parameters())
            return (weight.new_zeros(self.nlayers, bsz, self.nhid),
                    weight.new_zeros(self.nlayers, bsz, self.nhid))







2. Load in the text data
------------------------

Next, we load the
`Wikitext-2 dataset <https://www.google.com/search?q=wikitext+2+data>`_ into a `Corpus`,
again following the
`preprocessing <https://github.com/pytorch/examples/blob/master/word_language_model/data.py>`_
from the word language model example.


.. code-block:: default


    class Dictionary(object):
        def __init__(self):
            self.word2idx = {}
            self.idx2word = []

        def add_word(self, word):
            if word not in self.word2idx:
                self.idx2word.append(word)
                self.word2idx[word] = len(self.idx2word) - 1
            return self.word2idx[word]

        def __len__(self):
            return len(self.idx2word)


    class Corpus(object):
        def __init__(self, path):
            self.dictionary = Dictionary()
            self.train = self.tokenize(os.path.join(path, 'train.txt'))
            self.valid = self.tokenize(os.path.join(path, 'valid.txt'))
            self.test = self.tokenize(os.path.join(path, 'test.txt'))

        def tokenize(self, path):
            """Tokenizes a text file."""
            assert os.path.exists(path)
            # Add words to the dictionary
            with open(path, 'r', encoding="utf8") as f:
                for line in f:
                    words = line.split() + ['<eos>']
                    for word in words:
                        self.dictionary.add_word(word)

            # Tokenize file content
            with open(path, 'r', encoding="utf8") as f:
                idss = []
                for line in f:
                    words = line.split() + ['<eos>']
                    ids = []
                    for word in words:
                        ids.append(self.dictionary.word2idx[word])
                    idss.append(torch.tensor(ids).type(torch.int64))
                ids = torch.cat(idss)

            return ids

    model_data_filepath = 'data/'

    corpus = Corpus(model_data_filepath + 'wikitext-2')







3. Load the pre-trained model
-----------------------------

This is a tutorial on dynamic quantization, a quantization technique
that is applied after a model has been trained. Therefore, we'll simply load some
pre-trained weights into this model architecture; these weights were obtained
by training for five epochs using the default settings in the word language model
example.


.. code-block:: default


    ntokens = len(corpus.dictionary)

    model = LSTMModel(
        ntoken = ntokens,
        ninp = 512,
        nhid = 256,
        nlayers = 5,
    )

    model.load_state_dict(
        torch.load(
            model_data_filepath + 'word_language_model_quantize.pth',
            map_location=torch.device('cpu')
            )
        )

    model.eval()
    print(model)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    LSTMModel(
      (drop): Dropout(p=0.5, inplace=False)
      (encoder): Embedding(33278, 512)
      (rnn): LSTM(512, 256, num_layers=5, dropout=0.5)
      (decoder): Linear(in_features=256, out_features=33278, bias=True)
    )


Now let's generate some text to ensure that the pre-trained model is working
properly - similarly to before, we follow
`here <https://github.com/pytorch/examples/blob/master/word_language_model/generate.py>`_


.. code-block:: default


    input_ = torch.randint(ntokens, (1, 1), dtype=torch.long)
    hidden = model.init_hidden(1)
    temperature = 1.0
    num_words = 1000

    with open(model_data_filepath + 'out.txt', 'w') as outf:
        with torch.no_grad():  # no tracking history
            for i in range(num_words):
                output, hidden = model(input_, hidden)
                word_weights = output.squeeze().div(temperature).exp().cpu()
                word_idx = torch.multinomial(word_weights, 1)[0]
                input_.fill_(word_idx)

                word = corpus.dictionary.idx2word[word_idx]

                outf.write(str(word.encode('utf-8')) + ('\n' if i % 20 == 19 else ' '))

                if i % 100 == 0:
                    print('| Generated {}/{} words'.format(i, 1000))

    with open(model_data_filepath + 'out.txt', 'r') as outf:
        all_output = outf.read()
        print(all_output)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    | Generated 0/1000 words
    | Generated 100/1000 words
    | Generated 200/1000 words
    | Generated 300/1000 words
    | Generated 400/1000 words
    | Generated 500/1000 words
    | Generated 600/1000 words
    | Generated 700/1000 words
    | Generated 800/1000 words
    | Generated 900/1000 words
    b'by' b'met' b'"' b'monastic' b'deposits' b'"' b',' b'but' b'gave' b'greater' b'portions' b'of' b'stranded' b'swordsman' b'to' b'look' b'to' b'can' b'be' b'parishioners'
    b'.' b'There' b'has' b'also' b'been' b'suggested' b'that' b'of' b'the' b'FIA' b"'s" b'three' b'times' b'.' b'The' b'Residential' b'thoughts' b'was' b'further' b'yet'
    b'<unk>' b'as' b'salary' b'of' b'their' b'theatrical' b'beds' b'.' b'The' b'<unk>' b'<unk>' b'(' b'<unk>' b')' b'is' b'played' b',' b'but' b'in' b'1844'
    b'the' b'Isis' b'only' b'always' b'saw' b'place' b'during' b'the' b'north' b'of' b'Mexico' b'.' b'Four' b'landmarks' b'(' b'Andhra' b'RAF' b',' b'Administrative' b'&'
    b'S.' b')' b'acts' b'was' b'also' b'allowed' b'to' b'have' b'adopted' b'sixteen' b'shows' b',' b'which' b'Rebel' b'Power' b'Bang' b'novelist' b'describes' b'a' b'record'
    b'@-@' b'based' b'object' b'@-@' b'movies' b',' b'which' b'inscriptions' b'once' b'notes' b',' b'if' b'the' b'various' b'Lieberman' b're' b'@-@' b'Post' b'and' b'live'
    b'museums' b'for' b'stories' b'Sun' b'De' b'Aviv' b'.' b'Michael' b'Hammond' b'made' b'the' b'school' b'to' b'make' b'Per\xc3\xb3ns' b'as' b'they' b'DRS' b'.' b'<eos>'
    b'Ceres' b'committed' b'Benaim' b'to' b'privacy' b'recommending' b',' b'by' b'Providence' b',' b'and' b'account' b'of' b'Dublin' b'<unk>' b'in' b'Leinster' b'.' b'At' b'those'
    b'of' b'Wayne' b'visible' b'on' b'October' b'25' b',' b'1964' b',' b'John' b'Hasted' b'cited' b'his' b'<unk>' b'frames' b'to' b'Okay' b'Lomonosov' b"'s" b'Bosnians'
    b'in' b'a' b'video' b',' b'which' b'he' b'described' b'near' b'reasonably' b'racing' b'.' b'The' b'assessment' b'was' b'greatly' b'further' b'reject' b'.' b'<unk>' b'members'
    b'to' b'make' b'drawn' b'permission' b'turbines' b'to' b'mastermind' b'safety' b'on' b'a' b'legal' b'420' b'@-@' b'score' b'opening' b'in' b'Jeremy' b'Dixie' b',' b'is'
    b'commonly' b'included' b'to' b'be' b'also' b'rapidly' b'aimed' b'in' b'October' b'1949' b',' b'though' b'Vuthiphong' b'<unk>' b'made' b'to' b'his' b'songwriting' b'at' b'a'
    b'party' b'@-@' b'<unk>' b'Test' b'draft' b';' b'in' b'1898' b',' b'which' b'toured' b'the' b'frustrated' b'destination' b'with' b'Kody' b'.' b'With' b'Sleeping' b'teaching'
    b'is' b'omitted' b'with' b'De' b'Busqu\xc3\xa9' b"'s" b'intention' b'to' b'go' b'the' b'Soviet' b'or' b'great' b'New' b'Zealand' b',' b'the' b'quality' b'of' b'Hairan'
    b'Number' b'Castle' b'.' b'motorcycle' b'scenes' b'varied' b'ago' b',' b'<unk>' b',' b'<unk>' b'Karamchand' b'<unk>' b',' b'and' b'amateur' b'<unk>' b'of' b'<unk>' b'high'
    b'facilities' b'dreadnought' b'were' b'<unk>' b'by' b'nesting' b'Cooksey' b'outside' b'more' b'than' b'to' b'one' b'hundred' b'position' b',' b'primarily' b'even' b'in' b'<unk>' b','
    b'Virgil' b'areas' b',' b'and' b'power' b'play' b'.' b'If' b'Thee' b'worked' b'in' b'Australia' b'(' b'Pop' b'Asia' b')' b',' b'a' b'Rossiya' b'took'
    b'place' b'on' b'each' b'1' b'years' b',' b'and' b'never' b'ordered' b'crime' b'for' b'public' b'control' b'.' b'In' b'2008' b',' b'the' b'bi' b'<unk>'
    b'@-@' b'offs' b'were' b'established' b'to' b'have' b'been' b'listed' b'as' b'interpreting' b'skulls' b'during' b'his' b'association' b'at' b'Georgia' b',' b'while' b'the' b'hypothesis'
    b'gravestones' b'is' b'meaning' b'to' b'whether' b'standardized' b'books' b'were' b'still' b'limited' b'than' b'weapons' b'.' b'A' b'specific' b'agricultural' b'solution' b'was' b'massively' b'a'
    b'controller' b'known' b'as' b'Ceres' b'after' b'<unk>' b'interrelated' b'combatants' b',' b'soon' b'by' b'land' b',' b'about' b'sailors' b'engineers' b'than' b'their' b'Mode' b'.'
    b'Jim' b'Rector' b'claims' b'that' b'"' b'Q.' b'mankind' b'ceased' b'into' b'Italian' b'migrants' b'can' b'be' b'important' b'time' b'up' b'.' b'"' b'The' b'Annals'
    b'of' b'chaparral' b'in' b'Syria' b'began' b'a' b'African' b'language' b',' b'December' b'freeway' b'.' b'<eos>' b'Growth' b'longer' b'participants' b',' b'the' b'central' b'dissenting'
    b'species' b'and' b'physique' b',' b'deities' b'and' b'desire' b'<unk>' b'this' b'results' b'was' b'.' b'fishes' b'are' b'picked' b'back' b'to' b'Forgiveness' b',' b'such'
    b'as' b'examples' b'of' b'other' b'three' b'years' b'a' b'natural' b'will' b'be' b'heard' b'.' b'guttural' b'are' b'killed' b'"' b'genre' b'<unk>' b'"' b','
    b'creating' b'the' b'agents' b'firmly' b'Polish' b'or' b'soul' b'Wanderers' b'.' b'<eos>' b'<eos>' b'=' b'=' b'Discovery' b'=' b'=' b'<eos>' b'<eos>' b'The' b'hydrate'
    b'becomes' b'changed' b'to' b'nine' b'19th' b'faiths' b',' b'as' b'did' b'not' b'be' b're' b'@-@' b'Islamic' b'but' b'star' b'.' b'<unk>' b'growth' b'begin'
    b'during' b'cytoplasm' b'to' b'Japan' b'its' b'original' b'number' b'<unk>' b'upon' b'Jowhar' b'in' b'fusion' b'.' b'<unk>' b'are' b'famous' b'into' b'ancient' b'modifications' b'.'
    b'An' b'successful' b',' b'and' b'gold' b'<unk>' b',' b'Indra' b',' b'are' b'extend' b'by' b'Gruffudd' b'.' b'<eos>' b'Common' b'starlings' b'still' b'ran' b'with'
    b'the' b'regulation' b'of' b'plants' b'<unk>' b'@-@' b'"' b'<unk>' b'"' b'are' b'also' b'organized' b',' b'hoping' b'to' b'different' b'earth' b',' b'<unk>' b'@-@'
    b'Tbilisi' b'.' b'In' b'addition' b',' b'breeding' b'largest' b',' b'ingestion' b'fly' b'in' b'the' b'Republic' b',' b'<unk>' b'<unk>' b'museums' b'and' b'horizontal' b'transverse'
    b'practice' b'while' b'reviewed' b'neutrons' b',' b'each' b'surveillance' b'<unk>' b'an' b'parallel' b',' b'separated' b',' b'discomfort' b'hand' b'or' b'uniqueness' b'trees' b'that' b'can'
    b'affected' b'hours' b'and' b'grazing' b'.' b'globular' b'image' b'may' b'be' b'distinguished' b'by' b'their' b'large' b'terrain' b'and' b'prevent' b'whenever' b'orbit' b'in' b'a'
    b'few' b'loyal' b'origin' b'of' b'classroom' b'.' b'Many' b'sites' b'are' b'rarely' b'common' b',' b'so' b'as' b'they' b'observed' b'amazed' b'them' b'to' b'narrate'
    b'no' b'exception' b'of' b'food' b'.' b'<eos>' b'The' b'all' b'of' b'four' b'Ceres' b'is' b'originally' b'rarely' b'unknown' b',' b'ranging' b'to' b'<unk>' b'.'
    b'<unk>' b'tools' b'often' b'have' b'two' b'Formula' b'starlings' b',' b'as' b'Brown' b'is' b'activated' b'by' b'the' b'males' b'.' b'It' b'usually' b'grows' b'to'
    b'watch' b'a' b'large' b'indisputably' b'as' b'marries' b'.' b'<unk>' b'the' b'culling' b'may' b'suggest' b'at' b'a' b'average' b'of' b'feeding' b'daily' b'guess' b'ways'
    b',' b'saw' b'them' b'to' b'over' b'1' b'hundred' b'birds' b',' b'after' b'not' b'reports' b'of' b'G' b'restless' b'.' b'Incubation' b'will' b'remain' b'on'
    b'post' b'@-@' b'year' b',' b'except' b'their' b'species' b'from' b'12' b'ft' b'(' b'4' b'@.@' b'4' b'in' b')' b'in' b'diameter' b',' b'adjacent'
    b'to' b',' b'82' b'@.@' b'5' b'minutes' b',' b'and' b'with' b'females' b'villages' b'with' b'internal' b'females' b'.' b'vertices' b'prefer' b'themselves' b'to' b'succeed'
    b',' b'causing' b'a' b'small' b'amount' b'of' b'females' b'(' b'the' b'exercise' b'of' b'sex' b'with' b'black' b',' b'positive' b',' b'comfortable' b'and' b'yellow'
    b'balls' b')' b',' b'which' b'may' b'leave' b'they' b'are' b'unlikely' b'.' b'If' b'they' b'do' b'not' b'shortfall' b',' b'they' b'are' b'Unfortunately' b'with'
    b'proteins' b'.' b'There' b'are' b'no' b'lowest' b'atomic' b'ranks' b'that' b'they' b'break' b'Singapore' b',' b'her' b'scholars' b'ignore' b'these' b'one' b'or' b'reached'
    b'three' b'hours' b'.' b'Many' b'other' b'starlings' b'even' b'increase' b'all' b'years' b'before' b'they' b'have' b'its' b'grown' b'time' b'.' b'Females' b'prefix' b'only'
    b'less' b'males' b'down' b',' b'such' b',' b'but' b'cannot' b'be' b'when' b'they' b'resemble' b'some' b'eggs' b'.' b'By' b'eight' b'points' b'songs' b','
    b'they' b'are' b'connected' b'to' b'0' b'@.@' b'18' b'to' b'10' b'@.@' b'9' b'mm' b'(' b'5' b'@.@' b'8' b'in' b')' b',' b'and'
    b'are' b'provided' b'by' b'any' b'variable' b'bird' b'species' b'and' b'flown' b'above' b'20' b'or' b'24' b'females' b',' b'40' b'\xe2\x80\x93' b'10' b'@.@' b'8'
    b'vegetarian' b'(' b'7' b'@.@' b'4' b'heights' b')' b',' b'which' b'will' b'require' b'male' b'eggs' b'full' b'as' b'of' b'close' b',' b'and' b'they'
    b'may' b'react' b'the' b'season' b',' b'Majel' b'Australia' b'.' b'calls' b'<unk>' b'depends' b'at' b'Oslo' b',' b'where' b'they' b'form' b'smoking' b'.' b'Mottram'
    b'may' b'also' b'occupy' b'females' b',' b'and' b'from' b'enzyme' b',' b'thermal' b'for' b'the' b'bird' b'.' b'<unk>' b'of' b'Geastrum' b',' b'given' b'south'


It's no GPT-2, but it looks like the model has started to learn the structure of
language!

We're almost ready to demonstrate dynamic quantization. We just need to define a few more
helper functions:


.. code-block:: default


    bptt = 25
    criterion = nn.CrossEntropyLoss()
    eval_batch_size = 1

    # create test data set
    def batchify(data, bsz):
        # Work out how cleanly we can divide the dataset into bsz parts.
        nbatch = data.size(0) // bsz
        # Trim off any extra elements that wouldn't cleanly fit (remainders).
        data = data.narrow(0, 0, nbatch * bsz)
        # Evenly divide the data across the bsz batches.
        return data.view(bsz, -1).t().contiguous()

    test_data = batchify(corpus.test, eval_batch_size)

    # Evaluation functions
    def get_batch(source, i):
        seq_len = min(bptt, len(source) - 1 - i)
        data = source[i:i+seq_len]
        target = source[i+1:i+1+seq_len].view(-1)
        return data, target

    def repackage_hidden(h):
      """Wraps hidden states in new Tensors, to detach them from their history."""

      if isinstance(h, torch.Tensor):
          return h.detach()
      else:
          return tuple(repackage_hidden(v) for v in h)

    def evaluate(model_, data_source):
        # Turn on evaluation mode which disables dropout.
        model_.eval()
        total_loss = 0.
        hidden = model_.init_hidden(eval_batch_size)
        with torch.no_grad():
            for i in range(0, data_source.size(0) - 1, bptt):
                data, targets = get_batch(data_source, i)
                output, hidden = model_(data, hidden)
                hidden = repackage_hidden(hidden)
                output_flat = output.view(-1, ntokens)
                total_loss += len(data) * criterion(output_flat, targets).item()
        return total_loss / (len(data_source) - 1)







4. Test dynamic quantization
----------------------------

Finally, we can call ``torch.quantization.quantize_dynamic`` on the model!
Specifically,

- We specify that we want the ``nn.LSTM`` and ``nn.Linear`` modules in our
  model to be quantized
- We specify that we want weights to be converted to ``int8`` values


.. code-block:: default


    import torch.quantization

    quantized_model = torch.quantization.quantize_dynamic(
        model, {nn.LSTM, nn.Linear}, dtype=torch.qint8
    )
    print(quantized_model)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    LSTMModel(
      (drop): Dropout(p=0.5, inplace=False)
      (encoder): Embedding(33278, 512)
      (rnn): DynamicQuantizedLSTM(
        512, 256, num_layers=5, dropout=0.5
        (_all_weight_values): ModuleList(
          (0): PackedParameter()
          (1): PackedParameter()
          (2): PackedParameter()
          (3): PackedParameter()
          (4): PackedParameter()
          (5): PackedParameter()
          (6): PackedParameter()
          (7): PackedParameter()
          (8): PackedParameter()
          (9): PackedParameter()
        )
      )
      (decoder): DynamicQuantizedLinear(
        in_features=256, out_features=33278
        (_packed_params): LinearPackedParams()
      )
    )


The model looks the same; how has this benefited us? First, we see a
significant reduction in model size:


.. code-block:: default


    def print_size_of_model(model):
        torch.save(model.state_dict(), "temp.p")
        print('Size (MB):', os.path.getsize("temp.p")/1e6)
        os.remove('temp.p')

    print_size_of_model(model)
    print_size_of_model(quantized_model)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Size (MB): 113.941574
    Size (MB): 76.807204


Second, we see faster inference time, with no difference in evaluation loss:

Note: we number of threads to one for single threaded comparison, since quantized
models run single threaded.


.. code-block:: default


    torch.set_num_threads(1)

    def time_model_evaluation(model, test_data):
        s = time.time()
        loss = evaluate(model, test_data)
        elapsed = time.time() - s
        print('''loss: {0:.3f}\nelapsed time (seconds): {1:.1f}'''.format(loss, elapsed))

    time_model_evaluation(model, test_data)
    time_model_evaluation(quantized_model, test_data)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    loss: 5.167
    elapsed time (seconds): 239.0
    loss: 5.168
    elapsed time (seconds): 166.7


Running this locally on a MacBook Pro, without quantization, inference takes about 200 seconds,
and with quantization it takes just about 100 seconds.

Conclusion
----------

Dynamic quantization can be an easy way to reduce model size while only
having a limited effect on accuracy.

Thanks for reading! As always, we welcome any feedback, so please create an issue
`here <https://github.com/pytorch/pytorch/issues>`_ if you have any.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 6 minutes  50.384 seconds)


.. _sphx_glr_download_advanced_dynamic_quantization_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: dynamic_quantization_tutorial.py <dynamic_quantization_tutorial.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: dynamic_quantization_tutorial.ipynb <dynamic_quantization_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
