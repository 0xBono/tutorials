.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_advanced_static_quantization_tutorial.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_advanced_static_quantization_tutorial.py:


(experimental) Static Quantization with Eager Mode in PyTorch
=========================================================

**Author**: `Raghuraman Krishnamoorthi <https://github.com/raghuramank100>`_

**Edited by**: `Seth Weidman <https://github.com/SethHWeidman/>`_

This tutorial shows how to do post-training static quantization, as well as illustrating
two more advanced techniques - per-channel quantization and quantization-aware training -
to further improve the model's accuracy.

By the end of this tutorial, you will see how quantization in PyTorch can result in
significant decreases in model size while increasing speed. Furthermore, you'll see how
to easily apply some advanced quantization techniques shown
`here <https://arxiv.org/abs/1806.08342>`_ so that your quantized models take much less
of an accuracy hit than they would otherwise.

Warning: we use a lot of boilerplate code from other PyTorch repos to, for example,
define the ``MobileNetV2`` model archtecture, define data loaders, and so on. We of course
encourage you to read it; but if you want to get to the quantization features, feel free
to skip to the "4. Post-training static quantization" section.

We'll start by doing the necessary imports:


.. code-block:: default

    import numpy as np
    import torch
    import torch.nn as nn
    import torchvision
    from torch.utils.data import DataLoader
    from torchvision import datasets
    import torchvision.transforms as transforms
    import os
    import time
    import sys
    import torch.quantization

    # # Setup warnings
    import warnings
    warnings.filterwarnings(
        action='ignore',
        category=DeprecationWarning,
        module=r'.*'
    )
    warnings.filterwarnings(
        action='default',
        module=r'torch.quantization'
    )

    # Specify random seed for repeatable results
    torch.manual_seed(191009)







1. Model architecture
---------------------

We first define the MobileNetV2 model architecture, with several notable modifications
to enable quantization:

- Replacing addition with ``nn.quantized.FloatFunctional``
- Insert ``QuantStub`` and ``DeQuantStub`` at the beginning and end of the network.
- Replace ReLU6 with ReLU

Note that this code is taken from
`here <https://github.com/pytorch/vision/blob/master/torchvision/models/mobilenet.py>`_


.. code-block:: default


    from torch.quantization import QuantStub, DeQuantStub

    def _make_divisible(v, divisor, min_value=None):
        """
        This function is taken from the original tf repo.
        It ensures that all layers have a channel number that is divisible by 8
        It can be seen here:
        https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet/mobilenet.py
        :param v:
        :param divisor:
        :param min_value:
        :return:
        """
        if min_value is None:
            min_value = divisor
        new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)
        # Make sure that round down does not go down by more than 10%.
        if new_v < 0.9 * v:
            new_v += divisor
        return new_v


    class ConvBNReLU(nn.Sequential):
        def __init__(self, in_planes, out_planes, kernel_size=3, stride=1, groups=1):
            padding = (kernel_size - 1) // 2
            super(ConvBNReLU, self).__init__(
                nn.Conv2d(in_planes, out_planes, kernel_size, stride, padding, groups=groups, bias=False),
                nn.BatchNorm2d(out_planes, momentum=0.1),
                # Replace with ReLU
                nn.ReLU(inplace=False)
            )


    class InvertedResidual(nn.Module):
        def __init__(self, inp, oup, stride, expand_ratio):
            super(InvertedResidual, self).__init__()
            self.stride = stride
            assert stride in [1, 2]

            hidden_dim = int(round(inp * expand_ratio))
            self.use_res_connect = self.stride == 1 and inp == oup

            layers = []
            if expand_ratio != 1:
                # pw
                layers.append(ConvBNReLU(inp, hidden_dim, kernel_size=1))
            layers.extend([
                # dw
                ConvBNReLU(hidden_dim, hidden_dim, stride=stride, groups=hidden_dim),
                # pw-linear
                nn.Conv2d(hidden_dim, oup, 1, 1, 0, bias=False),
                nn.BatchNorm2d(oup, momentum=0.1),
            ])
            self.conv = nn.Sequential(*layers)
            # Replace torch.add with floatfunctional
            self.skip_add = nn.quantized.FloatFunctional()

        def forward(self, x):
            if self.use_res_connect:
                return self.skip_add.add(x, self.conv(x))
            else:
                return self.conv(x)


    class MobileNetV2(nn.Module):
        def __init__(self, num_classes=1000, width_mult=1.0, inverted_residual_setting=None, round_nearest=8):
            """
            MobileNet V2 main class

            Args:
                num_classes (int): Number of classes
                width_mult (float): Width multiplier - adjusts number of channels in each layer by this amount
                inverted_residual_setting: Network structure
                round_nearest (int): Round the number of channels in each layer to be a multiple of this number
                Set to 1 to turn off rounding
            """
            super(MobileNetV2, self).__init__()
            block = InvertedResidual
            input_channel = 32
            last_channel = 1280

            if inverted_residual_setting is None:
                inverted_residual_setting = [
                    # t, c, n, s
                    [1, 16, 1, 1],
                    [6, 24, 2, 2],
                    [6, 32, 3, 2],
                    [6, 64, 4, 2],
                    [6, 96, 3, 1],
                    [6, 160, 3, 2],
                    [6, 320, 1, 1],
                ]

            # only check the first element, assuming user knows t,c,n,s are required
            if len(inverted_residual_setting) == 0 or len(inverted_residual_setting[0]) != 4:
                raise ValueError("inverted_residual_setting should be non-empty "
                                 "or a 4-element list, got {}".format(inverted_residual_setting))

            # building first layer
            input_channel = _make_divisible(input_channel * width_mult, round_nearest)
            self.last_channel = _make_divisible(last_channel * max(1.0, width_mult), round_nearest)
            features = [ConvBNReLU(3, input_channel, stride=2)]
            # building inverted residual blocks
            for t, c, n, s in inverted_residual_setting:
                output_channel = _make_divisible(c * width_mult, round_nearest)
                for i in range(n):
                    stride = s if i == 0 else 1
                    features.append(block(input_channel, output_channel, stride, expand_ratio=t))
                    input_channel = output_channel
            # building last several layers
            features.append(ConvBNReLU(input_channel, self.last_channel, kernel_size=1))
            # make it nn.Sequential
            self.features = nn.Sequential(*features)
            self.quant = QuantStub()
            self.dequant = DeQuantStub()
            # building classifier
            self.classifier = nn.Sequential(
                nn.Dropout(0.2),
                nn.Linear(self.last_channel, num_classes),
            )

            # weight initialization
            for m in self.modules():
                if isinstance(m, nn.Conv2d):
                    nn.init.kaiming_normal_(m.weight, mode='fan_out')
                    if m.bias is not None:
                        nn.init.zeros_(m.bias)
                elif isinstance(m, nn.BatchNorm2d):
                    nn.init.ones_(m.weight)
                    nn.init.zeros_(m.bias)
                elif isinstance(m, nn.Linear):
                    nn.init.normal_(m.weight, 0, 0.01)
                    nn.init.zeros_(m.bias)

        def forward(self, x):

            x = self.quant(x)

            x = self.features(x)
            x = x.mean([2, 3])
            x = self.classifier(x)
            x = self.dequant(x)
            return x

        # Fuse Conv+BN and Conv+BN+Relu modules prior to quantization
        # This operation does not change the numerics
        def fuse_model(self):
            for m in self.modules():
                if type(m) == ConvBNReLU:
                    torch.quantization.fuse_modules(m, ['0', '1', '2'], inplace=True)
                if type(m) == InvertedResidual:
                    for idx in range(len(m.conv)):
                        if type(m.conv[idx]) == nn.Conv2d:
                            torch.quantization.fuse_modules(m.conv, [str(idx), str(idx + 1)], inplace=True)







2. Helper functions
-------------------

We next define several helper functions to help with model evaluation. These mostly come from
`here <https://github.com/pytorch/examples/blob/master/imagenet/main.py>`_.


.. code-block:: default


    class AverageMeter(object):
        """Computes and stores the average and current value"""
        def __init__(self, name, fmt=':f'):
            self.name = name
            self.fmt = fmt
            self.reset()

        def reset(self):
            self.val = 0
            self.avg = 0
            self.sum = 0
            self.count = 0

        def update(self, val, n=1):
            self.val = val
            self.sum += val * n
            self.count += n
            self.avg = self.sum / self.count

        def __str__(self):
            fmtstr = '{name} {val' + self.fmt + '} ({avg' + self.fmt + '})'
            return fmtstr.format(**self.__dict__)


    def accuracy(output, target, topk=(1,)):
        """Computes the accuracy over the k top predictions for the specified values of k"""
        with torch.no_grad():
            maxk = max(topk)
            batch_size = target.size(0)

            _, pred = output.topk(maxk, 1, True, True)
            pred = pred.t()
            correct = pred.eq(target.view(1, -1).expand_as(pred))
        #    print(target.view(1, -1).expand_as(pred), pred)
            res = []
            for k in topk:
                correct_k = correct[:k].view(-1).float().sum(0, keepdim=True)
                res.append(correct_k.mul_(100.0 / batch_size))
            return res


    def evaluate(model, criterion, data_loader, neval_batches):
        model.eval()
        top1 = AverageMeter('Acc@1', ':6.2f')
        top5 = AverageMeter('Acc@5', ':6.2f')
        cnt = 0
        with torch.no_grad():
            for image, target in data_loader:
                print(target)
                output = model(image)
                loss = criterion(output, target)
                cnt += 1
                acc1, acc5 = accuracy(output, target, topk=(1, 5))
                print('.', end = '')
                top1.update(acc1[0], image.size(0))
                top5.update(acc5[0], image.size(0))
                if cnt >= neval_batches:
                     return top1, top5

        return top1, top5

    def load_model(model_file):
        model = MobileNetV2()
        state_dict = torch.load(model_file)
        model.load_state_dict(state_dict)
        model.to('cpu')
        return model

    def print_size_of_model(model):
        torch.save(model.state_dict(), "temp.p")
        print('Size (MB):', os.path.getsize("temp.p")/1e6)
        os.remove('temp.p')







3. Define dataset and data loaders
----------------------------------

As our last major setup step, we define our dataloaders for our training and testing set.
The specific dataset we've created for this tutorial contains just 1000 images, one from
each class (this dataset, at just over 250 MB, is small enough that it can be downloaded
relatively easily). These functions mostly come from
`here <https://github.com/pytorch/vision/blob/master/references/detection/train.py>`_.


.. code-block:: default


    def prepare_data_loaders(data_path):

        traindir = os.path.join(data_path, 'train')
        valdir = os.path.join(data_path, 'val')
        normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                         std=[0.229, 0.224, 0.225])

        dataset = torchvision.datasets.ImageFolder(
            traindir,
            transforms.Compose([
                transforms.RandomResizedCrop(224),
                transforms.RandomHorizontalFlip(),
                transforms.ToTensor(),
                normalize,
            ]))

        dataset_test = torchvision.datasets.ImageFolder(
            valdir,
            transforms.Compose([
                transforms.Resize(256),
                transforms.CenterCrop(224),
                transforms.ToTensor(),
                normalize,
            ]))

        train_sampler = torch.utils.data.RandomSampler(dataset)
        test_sampler = torch.utils.data.SequentialSampler(dataset_test)

        data_loader = torch.utils.data.DataLoader(
            dataset, batch_size=train_batch_size,
            sampler=train_sampler)

        data_loader_test = torch.utils.data.DataLoader(
            dataset_test, batch_size=eval_batch_size,
            sampler=test_sampler)

        return data_loader, data_loader_test







Next, we'll load in the pre-trained MobileNetV2 model


.. code-block:: default


    data_path = 'data/imagenet_1k'
    saved_model_dir = 'data/'
    float_model_file = 'mobilenet_quantization.pth'
    scripted_float_model_file = 'mobilenet_quantization_scripted.pth'
    scripted_quantized_model_file = 'mobilenet_quantization_scripted_quantized.pth'

    train_batch_size = 30
    eval_batch_size = 30

    data_loader, data_loader_test = prepare_data_loaders(data_path)
    criterion = nn.CrossEntropyLoss()
    float_model = load_model(saved_model_dir + float_model_file).to('cpu')







Next, we'll "fuse modules"; this can both make the model faster by saving on memory access
while also improving numerical accuracy. While this can be used with any model, this is
especially common with quantized models.


.. code-block:: default


    print('\n Inverted Residual Block: Before fusion \n\n', float_model.features[1].conv)
    float_model.eval()

    # Fuses modules
    float_model.fuse_model()

    # Note fusion of Conv+BN+Relu and Conv+Relu
    print('\n Inverted Residual Block: After fusion\n\n',float_model.features[1].conv)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Inverted Residual Block: Before fusion 

     Sequential(
      (0): ConvBNReLU(
        (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False)
        (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (2): ReLU()
      )
      (1): Conv2d(32, 16, kernel_size=(1, 1), stride=(1, 1), bias=False)
      (2): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
    )

     Inverted Residual Block: After fusion

     Sequential(
      (0): ConvBNReLU(
        (0): ConvReLU2d(
          (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32)
          (1): ReLU()
        )
        (1): Identity()
        (2): Identity()
      )
      (1): Conv2d(32, 16, kernel_size=(1, 1), stride=(1, 1))
      (2): Identity()
    )


Finally to get a "baseline" accuracy, let's see the accuracy of our un-quantized model
with fused modules


.. code-block:: default


    num_eval_batches = 10

    print("Size of baseline model")
    print_size_of_model(float_model)

    top1, top5 = evaluate(float_model, criterion, data_loader_test, neval_batches=num_eval_batches)
    print('Evaluation accuracy on %d images, %2.2f'%(num_eval_batches * eval_batch_size, top1.avg))
    torch.jit.save(torch.jit.script(float_model), saved_model_dir + scripted_float_model_file)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Size of baseline model
    Size (MB): 13.98112
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Evaluation accuracy on 300 images, 78.00


You should see 78% accuracy on 300 images, a solid baseline for ImageNet,
especially considering our model is just 14.0 MB.

This will be our baseline to compare to. Next, let's try different quantization methods

4. Post-training static quantization
------------------------------------

Post-training static quantization involves not just converting the weights from float to int,
as in dynamic quantization, but also performing the additional step of first feeding batches
of data through the network and computing the resulting distributions of the different activations
(specifically, this is done by inserting `observer` modules at different points that record this
data). These distributions are then used to determine how the specifically the different activations
should be quantized at inference time (a simple technique would be to simply divide the entire range
of activations into 256 levels, but we support more sophisticated methods as well). Importantly,
this additional step allows us to pass quantized values between operations instead of converting these values to floats - and then back to ints - between every operation, resulting in a significant speed-up.


.. code-block:: default


    num_calibration_batches = 10

    myModel = load_model(saved_model_dir + float_model_file).to('cpu')
    myModel.eval()

    # Fuse Conv, bn and relu
    myModel.fuse_model()

    # Specify quantization configuration
    # Start with simple min/max range estimation and per-tensor quantization of weights
    myModel.qconfig = torch.quantization.default_qconfig
    print(myModel.qconfig)
    torch.quantization.prepare(myModel, inplace=True)

    # Calibrate first
    print('Post Training Quantization Prepare: Inserting Observers')
    print('\n Inverted Residual Block:After observer insertion \n\n', myModel.features[1].conv)

    # Calibrate with the training set
    evaluate(myModel, criterion, data_loader, neval_batches=num_calibration_batches)
    print('Post Training Quantization: Calibration done')

    # Convert to quantized model
    torch.quantization.convert(myModel, inplace=True)
    print('Post Training Quantization: Convert done')
    print('\n Inverted Residual Block: After fusion and quantization, note fused modules: \n\n',myModel.features[1].conv)

    print("Size of model after quantization")
    print_size_of_model(myModel)

    top1, top5 = evaluate(myModel, criterion, data_loader_test, neval_batches=num_eval_batches)
    print('Evaluation accuracy on %d images, %2.2f'%(num_eval_batches * eval_batch_size, top1.avg))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    QConfig(activation=functools.partial(<class 'torch.quantization.observer.MinMaxObserver'>, reduce_range=True), weight=functools.partial(<class 'torch.quantization.observer.MinMaxObserver'>, dtype=torch.qint8, qscheme=torch.per_tensor_symmetric))
    Post Training Quantization Prepare: Inserting Observers

     Inverted Residual Block:After observer insertion 

     Sequential(
      (0): ConvBNReLU(
        (0): ConvReLU2d(
          (0): Conv2d(
            32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32
            (observer): MinMaxObserver(min_val=None, max_val=None)
          )
          (1): ReLU(
            (observer): MinMaxObserver(min_val=None, max_val=None)
          )
        )
        (1): Identity()
        (2): Identity()
      )
      (1): Conv2d(
        32, 16, kernel_size=(1, 1), stride=(1, 1)
        (observer): MinMaxObserver(min_val=None, max_val=None)
      )
      (2): Identity()
    )
    tensor([122, 387, 716, 843, 582, 344, 530, 506, 380, 737, 260, 650,  84, 587,
            285,  60, 359, 480, 120, 240, 519,  61, 384, 176, 712, 973, 849, 856,
            526, 368])
    .tensor([942, 992, 396, 103, 692, 703, 482, 290, 896, 448,  88, 394, 962, 328,
            905, 756, 301, 562, 305, 696, 946, 140, 898, 481, 392, 688, 881, 375,
            619, 883])
    .tensor([477, 627, 237, 345, 573, 577,  57, 651, 537, 338, 505, 168, 779, 575,
            698, 540, 420, 584, 643, 709,  73,  25, 110, 906, 229, 899, 198, 422,
            370, 124])
    .tensor([829, 131, 500, 797, 993, 932, 149, 508, 981, 365, 254, 352, 406, 219,
            369, 127, 291, 313, 362, 862, 618, 116, 873, 163,  20, 546, 831, 647,
            322, 105])
    .tensor([799, 842, 943, 476, 770, 348, 298, 280, 888,  23, 275, 214, 997, 113,
            585, 664, 600, 409,  21, 315, 473, 900, 741, 183, 728, 952, 485, 539,
            964, 908])
    .tensor([444, 819, 281, 385, 126,  62, 917, 822, 244, 404, 297, 889,  31, 837,
            438,   2, 155,  82, 523, 717, 768, 561, 704, 165, 940, 397,  47, 284,
            225, 722])
    .tensor([662, 963, 317, 252, 216, 517, 450, 853, 536,   8, 346, 743, 924, 588,
             78, 522, 624, 272, 621, 487, 278, 274, 556,  50, 554, 614, 263, 713,
            724, 439])
    .tensor([708, 892, 353, 603, 953, 146, 834, 232, 283, 893, 154, 736, 714, 995,
            192, 730, 557, 416, 785, 337, 503, 246, 319, 816, 383, 645, 357, 330,
            996, 949])
    .tensor([ 11, 824, 864,   9, 691,  38, 169, 933, 307, 931, 983, 794, 707, 681,
            145, 818,  13, 356, 871, 655,  42,  19, 454, 936,  77, 185, 374, 812,
            104, 449])
    .tensor([747, 489, 201, 865, 711, 193, 630, 761, 579, 267, 428, 656, 203, 202,
            172, 990, 652, 975, 139, 504, 860,  18, 316, 535, 308,  37, 156, 813,
            620, 179])
    .Post Training Quantization: Calibration done
    Post Training Quantization: Convert done

     Inverted Residual Block: After fusion and quantization, note fused modules: 

     Sequential(
      (0): ConvBNReLU(
        (0): QuantizedConvReLU2d(32, 32, kernel_size=(3, 3), stride=(1, 1), scale=0.16678406298160553, zero_point=0, padding=(1, 1), groups=32)
        (1): Identity()
        (2): Identity()
      )
      (1): QuantizedConv2d(32, 16, kernel_size=(1, 1), stride=(1, 1), scale=0.22515465319156647, zero_point=71)
      (2): Identity()
    )
    Size of model after quantization
    Size (MB): 3.588979
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Evaluation accuracy on 300 images, 64.67


For this quantized model, we see a significantly lower accuracy of just 62.33% on these same 30
images. Nevertheless, we did reduce the size of our model down to just under 3.6 MB, almost a 4x
decrease.

In addition, we can significantly improve on the accuracy simply by using a different
quantization configuration. We repeat the same exercise with the recommended configuration for
quantizing for x86 architectures. This configuration does the following:

- Quantizes weights on a per-channel basis
- Uses a histogram observer that collects a histogram of activations and then picks
  quantization parameters in an optimal manner.



.. code-block:: default


    per_channel_quantized_model = load_model(saved_model_dir + float_model_file)
    per_channel_quantized_model.eval()
    per_channel_quantized_model.fuse_model()
    per_channel_quantized_model.qconfig = torch.quantization.get_default_qconfig('fbgemm')
    print(per_channel_quantized_model.qconfig)

    torch.quantization.prepare(per_channel_quantized_model, inplace=True)
    evaluate(per_channel_quantized_model,criterion, data_loader, num_calibration_batches)
    torch.quantization.convert(per_channel_quantized_model, inplace=True)
    top1, top5 = evaluate(per_channel_quantized_model, criterion, data_loader_test, neval_batches=num_eval_batches)
    print('Evaluation accuracy on %d images, %2.2f'%(num_eval_batches * eval_batch_size, top1.avg))
    torch.jit.save(torch.jit.script(per_channel_quantized_model), saved_model_dir + scripted_quantized_model_file)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    QConfig(activation=functools.partial(<class 'torch.quantization.observer.HistogramObserver'>, reduce_range=True), weight=functools.partial(<class 'torch.quantization.observer.PerChannelMinMaxObserver'>, dtype=torch.qint8, qscheme=torch.per_channel_symmetric))
    tensor([584, 465, 952, 511, 443, 570,  95, 158, 826,  35, 838, 769, 104, 782,
            133,  97, 819, 703, 577, 978, 586, 526, 678, 775, 934, 578, 647, 837,
            227, 116])
    .tensor([850,  22, 230, 348, 923, 513, 191, 723, 890, 846, 644, 377,  29, 476,
             83, 143, 725, 257, 392, 406, 352, 564, 209, 840, 496, 103, 994, 351,
            414, 375])
    .tensor([ 55, 291, 821, 625, 609, 453, 855, 832, 434,  85, 404, 160, 240, 745,
            976, 784, 957, 672, 985, 931, 901, 700,  19, 184, 122, 105, 340, 988,
            179, 341])
    .tensor([303, 283, 847, 646, 483, 289,  65, 471, 288, 808, 484, 373, 941, 698,
            435, 346,  62, 153,   5, 946,  26, 138, 494, 286, 549,   9, 458, 756,
            924, 654])
    .tensor([328, 556, 802, 399, 967,  28, 910, 297, 330, 449, 425, 938, 343, 735,
            331, 472,  23, 140, 618, 468, 779, 608, 381, 173, 114, 372, 585, 566,
            848, 430])
    .tensor([ 40, 791, 363, 661, 135, 181, 882, 937, 522, 900, 523, 968, 681,  20,
            495,  79, 432, 963, 740, 797, 207, 628, 859, 951, 510, 768, 650, 991,
            886, 255])
    .tensor([673, 353, 954, 865, 800, 559, 407, 266, 834,  27, 928, 195, 939, 699,
            420, 926, 204, 313, 711, 332, 831, 541, 518, 127, 115, 836, 659, 444,
            117, 338])
    .tensor([ 70, 751, 182, 894, 256, 989,   8, 871, 786, 645, 603,  32, 873, 696,
            357, 358, 185, 427, 987, 649, 841, 796, 932, 285, 857, 302, 959, 953,
            159, 264])
    .tensor([706, 109, 152,  77, 273,  98, 638, 759, 171, 773, 736,  24, 811, 417,
             69, 112, 807, 478, 307, 306, 551, 490, 707, 310, 591, 145, 883, 944,
            292, 335])
    .tensor([416, 241, 641, 593, 296, 339, 809, 580, 246, 998,  61, 684, 758,  53,
            965, 527, 121, 766, 287, 130, 774, 582, 657, 388,  47, 124, 733,  99,
            216,  91])
    .tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Evaluation accuracy on 300 images, 77.00


Changing just this quantization configuration method resulted in an increase
of the accuracy to 74%! Still, this is 4% worse than the baseline of 78% achieved above.
So lets try quantization aware training.

5. Quantization-aware training
------------------------------

Quantization-aware training (QAT) is the quantization method that typically results in the highest accuracy.
With QAT, all weights and activations are “fake quantized” during both the forward and backward passes of
training: that is, float values are rounded to mimic int8 values, but all computations are still done with
floating point numbers. Thus, all the weight adjustments during training are made while “aware” of the fact
that the model will ultimately be quantized; after quantizing, therefore, this method will usually yield
higher accuracy than either dynamic quantization or post-training static quantization.

The overall workflow for actually performing QAT is very similar to before:

- We can use the same model as before: there is no additional preparation needed for quantization-aware
  training.
- We need to use a ``qconfig`` specifying what kind of fake-quantization is to be inserted after weights
  and activations, instead of specifying observers

We first define a training function:


.. code-block:: default


    def train_one_epoch(model, criterion, optimizer, data_loader, device, ntrain_batches):
        model.train()
        top1 = AverageMeter('Acc@1', ':6.2f')
        top5 = AverageMeter('Acc@5', ':6.2f')
        avgloss = AverageMeter('Loss', '1.5f')

        cnt = 0
        for image, target in data_loader:
            start_time = time.time()
            print('.', end = '')
            cnt += 1
            image, target = image.to(device), target.to(device)
            output = model(image)
            loss = criterion(output, target)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            acc1, acc5 = accuracy(output, target, topk=(1, 5))
            top1.update(acc1[0], image.size(0))
            top5.update(acc5[0], image.size(0))
            avgloss.update(loss, image.size(0))
            if cnt >= ntrain_batches:
                print('Loss', avgloss.avg)

                print('Training: * Acc@1 {top1.avg:.3f} Acc@5 {top5.avg:.3f}'
                      .format(top1=top1, top5=top5))
                return

        print('Full imagenet train set:  * Acc@1 {top1.global_avg:.3f} Acc@5 {top5.global_avg:.3f}'
              .format(top1=top1, top5=top5))
        return







We fuse modules as before


.. code-block:: default


    qat_model = load_model(saved_model_dir + float_model_file)
    qat_model.fuse_model()

    optimizer = torch.optim.SGD(qat_model.parameters(), lr = 0.0001)
    qat_model.qconfig = torch.quantization.get_default_qat_qconfig('fbgemm')







Finally, ``prepare_qat`` performs the "fake quantization", preparing the model for quantization-aware
training


.. code-block:: default


    torch.quantization.prepare_qat(qat_model, inplace=True)
    print('Inverted Residual Block: After preparation for QAT, note fake-quantization modules \n',qat_model.features[1].conv)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Inverted Residual Block: After preparation for QAT, note fake-quantization modules 
     Sequential(
      (0): ConvBNReLU(
        (0): ConvBnReLU2d(
          32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=32, bias=False
          (observer): FakeQuantize(
            fake_quant_enabled=True, observer_enabled=True,            scale=None, zero_point=None
            (observer): MovingAverageMinMaxObserver(min_val=None, max_val=None)
          )
          (weight_fake_quant): FakeQuantize(
            fake_quant_enabled=True, observer_enabled=True,            scale=None, zero_point=None
            (observer): MovingAveragePerChannelMinMaxObserver(min_val=None, max_val=None)
          )
        )
        (1): Identity()
        (2): Identity()
      )
      (1): ConvBn2d(
        32, 16, kernel_size=(1, 1), stride=(1, 1), bias=False
        (observer): FakeQuantize(
          fake_quant_enabled=True, observer_enabled=True,            scale=None, zero_point=None
          (observer): MovingAverageMinMaxObserver(min_val=None, max_val=None)
        )
        (weight_fake_quant): FakeQuantize(
          fake_quant_enabled=True, observer_enabled=True,            scale=None, zero_point=None
          (observer): MovingAveragePerChannelMinMaxObserver(min_val=None, max_val=None)
        )
      )
      (2): Identity()
    )


Training a quantized model with high accuracy requires accurate modeling of numerics at
inference. For quantization aware training, therefore, we modify the training loop by:

- Switch batch norm to use running mean and variance towards the end of training to better
  match inference numerics.
- We also freeze the quantizer parameters (scale and zero-point) and fine tune the weights.


.. code-block:: default


    num_train_batches = 20

    # Train and check accuracy after each epoch
    for nepoch in range(8):
        train_one_epoch(qat_model, criterion, optimizer, data_loader, torch.device('cpu'), num_train_batches)
        if nepoch > 3:
            # Freeze quantizer parameters
            qat_model.apply(torch.quantization.disable_observer)
        if nepoch > 2:
            # Freeze batch norm mean and variance estimates
            qat_model.apply(torch.nn.intrinsic.qat.freeze_bn_stats)

        # Check the accuracy after each epoch
        quantized_model = torch.quantization.convert(qat_model.eval(), inplace=False)
        quantized_model.eval()
        top1, top5 = evaluate(quantized_model,criterion, data_loader_test, neval_batches=num_eval_batches)
        print('Epoch %d :Evaluation accuracy on %d images, %2.2f'%(nepoch, num_eval_batches * eval_batch_size, top1.avg))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ....................Loss tensor(2.3555, grad_fn=<DivBackward0>)
    Training: * Acc@1 48.667 Acc@5 72.000
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 0 :Evaluation accuracy on 300 images, 73.33
    ....................Loss tensor(2.1775, grad_fn=<DivBackward0>)
    Training: * Acc@1 52.000 Acc@5 75.667
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 1 :Evaluation accuracy on 300 images, 75.00
    ....................Loss tensor(2.2601, grad_fn=<DivBackward0>)
    Training: * Acc@1 52.333 Acc@5 73.667
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 2 :Evaluation accuracy on 300 images, 75.00
    ....................Loss tensor(2.0853, grad_fn=<DivBackward0>)
    Training: * Acc@1 52.500 Acc@5 77.667
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 3 :Evaluation accuracy on 300 images, 76.33
    ....................Loss tensor(1.9736, grad_fn=<DivBackward0>)
    Training: * Acc@1 57.500 Acc@5 78.500
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 4 :Evaluation accuracy on 300 images, 76.67
    ....................Loss tensor(1.9349, grad_fn=<DivBackward0>)
    Training: * Acc@1 57.667 Acc@5 78.833
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 5 :Evaluation accuracy on 300 images, 77.00
    ....................Loss tensor(1.9763, grad_fn=<DivBackward0>)
    Training: * Acc@1 55.667 Acc@5 78.167
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 6 :Evaluation accuracy on 300 images, 76.67
    ....................Loss tensor(1.9253, grad_fn=<DivBackward0>)
    Training: * Acc@1 58.167 Acc@5 80.333
    tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
    .tensor([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59])
    .tensor([60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89])
    .tensor([ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,
            104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
            118, 119])
    .tensor([120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
            134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
            148, 149])
    .tensor([150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
            164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179])
    .tensor([180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
            194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209])
    .tensor([210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
            238, 239])
    .tensor([240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
            254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
            268, 269])
    .tensor([270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
            284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
            298, 299])
    .Epoch 7 :Evaluation accuracy on 300 images, 76.00


Here, we just perform quantization-aware training for a small number of epochs. Nevertheless,
quantization-aware training yields an accuracy of over 71% on the entire imagenet dataset,
which is close to the floating point accuracy of 71.9%.

More on quantization-aware training:

- QAT is a super-set of post training quant techniques that allows for more debugging.
  For example, we can analyze if the accuracy of the model is limited by weight or activation
  quantization.
- We can also simulate the accuracy of a quantized model in floating point since
  we are using fake-quantization to model the numerics of actual quantized arithmetic.
- We can mimic post training quantization easily too.

Speedup from quantization
^^^^^^^^^^^^^^^^^^^^^^^^^

Finally, let's confirm something we alluded to above: do our quantized models actually perform inference
faster? Let's test:


.. code-block:: default


    def run_benchmark(model_file, img_loader):
        elapsed = 0
        model = torch.jit.load(model_file)
        model.eval()
        num_batches = 5
        # Run the scripted model on a few batches of images
        for i, (images, target) in enumerate(img_loader):
            if i < num_batches:
                start = time.time()
                output = model(images)
                end = time.time()
                elapsed = elapsed + (end-start)
            else:
                break
        num_images = images.size()[0] * num_batches

        print('Elapsed time: %3.0f ms' % (elapsed/num_images*1000))
        return elapsed

    run_benchmark(saved_model_dir + scripted_float_model_file, data_loader_test)

    run_benchmark(saved_model_dir + scripted_quantized_model_file, data_loader_test)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Elapsed time:  11 ms
    Elapsed time:   9 ms


Running this locally on a MacBook pro yielded 61 ms for the regular model, and
just 20 ms for the quantized model, illustrating the typical 2-4x speedup
we see for quantized models compared to floating point ones.

Conclusion
----------

In this tutorial, we showed two quantization methods - post-training static quantization,
and quantization-aware training - describing what they do "under the hood" and how to use
them in PyTorch.

Thanks for reading! As always, we welcome any feedback, so please create an issue
`here <https://github.com/pytorch/pytorch/issues>`_ if you have any.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 11 minutes  15.362 seconds)


.. _sphx_glr_download_advanced_static_quantization_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: static_quantization_tutorial.py <static_quantization_tutorial.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: static_quantization_tutorial.ipynb <static_quantization_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
